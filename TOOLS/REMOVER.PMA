; Copyright 2022 Hideki EIRAKU <hdk_2@users.sourceforge.net>
; 
; Permission is hereby granted, free of charge, to any person obtaining
; a copy of this software and associated documentation files (the
; "Software"), to deal in the Software without restriction, including
; without limitation the rights to use, copy, modify, merge, publish,
; distribute, sublicense, and/or sell copies of the Software, and to
; permit persons to whom the Software is furnished to do so, subject to
; the following conditions:
; 
; The above copyright notice and this permission notice shall be
; included in all copies or substantial portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
{(IF(THEN,ELSE,ENDIF))}                                                         
{(WHILE(LOOP,DO,DONE))}

A	SEGMENT
	ASSUME	CS:A,DS:A,ES:A,SS:A
	ORG	100H
START:
	CMP	SP,OFFSET STOR+STORSIZE
	JAE	STACK_OK
	RET
STACK_OK:
	MOV	SP,OFFSET STACK
	MOV	BX,80H
	MOV	AL,[BX]
	CBW
	INC	BX
	ADD	BX,AX
	MOV	BYTE PTR [BX],0
	MOV	AX,82H
	PUSH	AX
	CALL	MAIN
	MOV	AH,4CH
	INT	21H

SIZEOF_BUF	EQU	128
STORSIZE	EQU	32768
STOR_SYM	EQU	1
STOR_BEGIN	EQU	2
STOR_END	EQU	4
STOR_REL	EQU	8
STOR_NEED	EQU	16

CHAR_SEPARATOR	EQU	0
CHAR_COMMENT	EQU	2
CHAR_STRING	EQU	3
CHAR_SYMBOL	EQU	4
CHAR_OPERATOR	EQU	5
CHAR_SYMOPE_BIT	EQU	4

S_HASH	STRUC
HA_NEXT	DW	?		; Pointer to next entry of same hash
HA_SYM	DW	?		; Pointer to symbol word structure
HA_NLEN	DB	?		; Name length
HA_NAME	DB	?		; Name starts here
S_HASH	ENDS

S_SYM	STRUC
SY_NEXT	DW	?		; Pointer to next of same group circular list
SY_REL	DW	?		; Pointer to related word list
SY_NEED	DB	?		; Need flag
S_SYM	ENDS

S_REL	STRUC
RE_NEXT	DW	?		; Pointer to next related word
RE_HASH	DW	?		; Pointer to S_HASH for referencing name
S_REL	ENDS

;;; Simplified example:
;;;  NAME1 EQU 1
;;;  NAME2 STRUC
;;;  NAME3 DB ?
;;;  NAME4 DB (SIZE NAME5) DUP (?)
;;;  NAME2 ENDS
;;;  hash("NAME1")=0, hash("NAME2")=0,
;;;  hash("NAME3")=1, hash("NAME4")=1,
;;;  hash("NAME5")=2
;;; HASHTBL[0] -> HASH2
;;; HASHTBL[1] -> HASH4
;;; HASHTBL[2] -> HASH5
;;; HASH1: S_HASH(SYM1,"NAME1") -> NULL
;;; HASH2: S_HASH(SYM2,"NAME2") -> HASH1
;;; HASH3: S_HASH(SYM3,"NAME3") -> NULL
;;; HASH4: S_HASH(SYM4,"NAME4") -> HASH3
;;; HASH5: S_HASH(NULL,"NAME5") -> NULL
;;; SYM1: S_SYM(REL1) -> SYM1
;;; SYM2: S_SYM(REL2) -> SYM3
;;; SYM3: S_SYM(REL3) -> SYM4
;;; SYM4: S_SYM(REL4) -> SYM2
;;; REL1: S_REL(HASH1) -> NULL
;;; REL2: S_REL(HASH2) -> NULL
;;; REL3: S_REL(HASH3) -> NULL
;;; REL4: S_REL(HASH5) -> S_REL(HASH4) -> NULL
;;; Insert a list:
;;;   p->next=current
;;;   current=p
;;; Insert a circular list:
;;;   if current=NULL then
;;;     p->next=p
;;;     current=p
;;;   else
;;;     p->next=current->next
;;;     current->next=p
;;;     current=p
;;;   end if

SYMCUR	DW	0
HASHTBL	DW	256 DUP (0)

{(PROC(HASHADR))
 {(ARG(BUF,LEN))
	MOV	SI,%BUF%
	MOV	CX,%LEN%
	CLD
	XOR	BX,BX
	{(WHILE)
		JCXZ	%DONE%
	%LOOP%:
		LODSB
		OR	AL,'a'-'A'
		ROL	BL,1
		ADD	BL,AL
		LOOP	%LOOP%
	%DONE%:
	}
	MOV	AX,BX
	ADD	AX,BX
	ADD	AX,OFFSET HASHTBL
 }
}

{(PROC(ERR_EXIT))
 {(ARG(MESSAGE))
	MOV	BX,%MESSAGE%
	MOV	DX,BX
	{(WHILE)
	%LOOP%:
		CMP	BYTE PTR [BX],0
		JE	%DONE%
		INC	BX
		JMP	%LOOP%
	%DONE%:
	}
	MOV	CX,BX
	SUB	CX,DX
	MOV	BX,2
	MOV	AH,40H
	INT	21H
	MOV	DX,OFFSET STR_CRLF
	MOV	CX,2
	MOV	BX,2
	MOV	AH,40H
	INT	21H
	MOV	AX,4C01H
	INT	21H
 }
}

{(PROC(OPEN_FOR_READ))
 {(ARG(FILENAME))
	MOV	DX,%FILENAME%
	MOV	AX,3D00H
	INT	21H
	{(IF)
		JNC	%ENDIF%
		XOR	AX,AX
	%ENDIF%:
	}
 }
}

{(PROC(CLOSE))
 {(ARG(FP))
	MOV	BX,%FP%
	MOV	AH,3EH
	INT	21H
 }
}

{(PROC(REWIND))
 {(ARG(FP))
	XOR	DX,DX
	XOR	CX,CX
	MOV	BX,%FP%
	MOV	AX,4200H
	INT	21H
 }
}

{(PROC(PRINT))
 {(ARG(STR))
	MOV	BX,%STR%
	MOV	DX,BX
	{(WHILE)
	%LOOP%:
		CMP	BYTE PTR [BX],0
		JE	%DONE%
		INC	BX
		JMP	%LOOP%
	%DONE%:
	}
	MOV	CX,BX
	SUB	CX,DX
	{(IF)
		JE	%ENDIF%
		MOV	BX,1
		MOV	AH,40H
		INT	21H
		{(IF)
			JC	%THEN%
			CMP	AX,CX
			JE	%ENDIF%
		%THEN%:
			MOV	AX,OFFSET MSG_WRITE_ERROR
			PUSH	AX
			CALL	ERR_EXIT
			POP	AX
		%ENDIF%:
		}
	%ENDIF%:
	}
 }
}

{(PROC(PRINT_VALUE))
 {(ARG(VALUE))
	MOV	AX,%VALUE%
	{(IF)
		MOV	CX,10
		CMP	AX,CX
		JB	%ENDIF%
		XOR	DX,DX
		DIV	CX
		MOV	%VALUE%,DX
		PUSH	AX
		CALL	PRINT_VALUE
		POP	AX
	%ENDIF%:
	}
	LEA	BX,%VALUE%
	ADD	BYTE PTR [BX],'0'
	PUSH	BX
	CALL	PRINT
	POP	AX
 }
}

{(PROC(GET_LINE))
 {(ARG(FP,BUF,BUFSIZE))
  {(LOCAL(C,I,GETCBUF))
	MOV	WORD PTR %I%,0
	{(WHILE)
	%LOOP%:
		MOV	AX,%I%
		CMP	AX,%BUFSIZE%
		JB	%DO%
		MOV	AX,OFFSET MSG_TOOLONG
		PUSH	AX
		CALL	ERR_EXIT
		POP	AX
	%DO%:
		{(IF)
			LEA	DX,%GETCBUF%
			MOV	CX,1
			MOV	BX,%FP%
			MOV	AH,3FH
			INT	21H
			JC	%THEN%
			CMP	AX,1
			MOV	AL,%GETCBUF%
			JE	%ENDIF%
		%THEN%:
			MOV	AX,-1
		%ENDIF%:
		}
		AND	AL,7FH
		CMP	AL,13
		JE	%DO%
		{(IF)
			CMP	AL,26
			JNE	%ENDIF%
			MOV	AX,-1
		%ENDIF%:
		}
		CMP	AL,0
		JE	%DO%
		{(IF)
			TEST	AX,AX
			JS	%THEN%
			CMP	AL,10
			JNE	%ENDIF%
		%THEN%:
			MOV	BX,%BUF%
			ADD	BX,%I%
			MOV	BYTE PTR [BX],0
			{(IF)
				CMP	WORD PTR %I%,0
				JA	%ELSE%
				TEST	AX,AX
				JNS	%ELSE%
				XOR	AX,AX
				JMP	SHORT %DONE%
			%ELSE%:
				MOV	AX,1
				JMP	SHORT %DONE%
			}
		%ENDIF%:
		}
		MOV	BX,%BUF%
		ADD	BX,%I%
		MOV	[BX],AL
		INC	WORD PTR %I%
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(GET_WORD_START))
 {(ARG(BUF))
	MOV	DL,CHAR_SEPARATOR
	MOV	SI,%BUF%
	CLD
	XOR	AX,AX
	MOV	BX,OFFSET TYPETBL
	{(WHILE)
	%LOOP%:
		LODSB
		CMP	AL,0
		JE	%DONE%
		XLAT
		AND	AL,0F0H
		OR	AL,DL
		XLAT
		AND	AL,0FH
		MOV	DL,AL
		TEST	AL,CHAR_SYMOPE_BIT
		JE	%LOOP%
	%DONE%:
	}
	LEA	AX,[SI-1]
 }
}

{(PROC(GET_WORD_LEN))
 {(ARG(BUF))
	XOR	CX,CX
	MOV	SI,%BUF%
	XOR	AX,AX
	CLD
	LODSB
	{(IF)
		CMP	AL,0
		JE	%ENDIF%
		MOV	BX,OFFSET TYPETBL
		XLAT
		AND	AL,0F0H
		XLAT
		AND	AL,0FH
		MOV	DL,AL
		DEC	CX
		{(IF)
			TEST	AL,CHAR_SYMOPE_BIT
			JE	%ENDIF%
			{(WHILE)
			%LOOP%:
				LODSB
				CMP	AL,0
				JE	%DONE%
				XLAT
				AND	AL,0F0H
				OR	AL,DL
				XLAT
				AND	AL,0FH
				CMP	AL,DL
				LOOPE	%LOOP%
				INC	CX
			%DONE%:
			}
		%ENDIF%:
		}
	%ENDIF%:
	}
	NEG	CX
	MOV	AX,CX
 }
}

{(PROC(TO_UPPER_ASM))
	{(IF)
		CMP	AL,'a'
		JB	%ENDIF%
		CMP	AL,'z'
		JA	%ENDIF%
		SUB	AL,'a'-'A'
	%ENDIF%:
	}
	RET
}

{(PROC(CMP_WORD))
 {(ARG(S1,S1LEN,S2,S2LEN))
	{((LOOP,EQU,DIF,END))
		MOV	AX,%S1LEN%
		CMP	AX,%S2LEN%
		JNE	%DIF%
		MOV	CX,AX
		JCXZ	%EQU%
		MOV	SI,%S1%
		MOV	DI,%S2%
		CLD
	%LOOP%:
		LODSB
		XCHG	SI,DI
		CALL	TO_UPPER_ASM
		MOV	DL,AL
		LODSB
		XCHG	SI,DI
		CALL	TO_UPPER_ASM
		CMP	AL,DL
		LOOPE	%LOOP%
		JNE	%DIF%
	%EQU%:
		MOV	AX,1
		JMP	SHORT %END%
	%DIF%:
		XOR	AX,AX
	%END%:
	}
 }
}

{(PROC(GET_STRING))
 {(ARG(BUF))
  {(LOCAL(I))
	MOV	WORD PTR %I%,0
	{(WHILE)
	%LOOP%:
		MOV	BX,%BUF%
		ADD	BX,%I%
		XOR	AX,AX
		MOV	AL,[BX]
		CMP	AL,0
		JE	%DONE%
		{(IF)
			CMP	AL,' '
			JA	%ENDIF%
			MOV	BYTE PTR [BX],0
			JMP	SHORT %DONE%
		%ENDIF%:
		}
		CALL	TO_UPPER_ASM
		MOV	BX,%BUF%
		ADD	BX,%I%
		MOV	[BX],AL
		INC	WORD PTR %I%
		JMP	%LOOP%
	%DONE%:
	}
	MOV	AX,%BUF%
  }
 }
}

{(PROC(FIND_NAME))
 {(ARG(WORD,WORDLEN))
	PUSH	%WORDLEN%
	PUSH	%WORD%
	CALL	HASHADR
	ADD	SP,4
	MOV	BX,AX
	SUB	BX,OFFSET HA_NEXT
	{((LOOP,NOTF,FND,END))
	%LOOP%:
		MOV	BX,[BX.HA_NEXT]
		TEST	BX,BX
		JE	%NOTF%
		XOR	AX,AX
		MOV	AL,[BX.HA_NLEN]
		MOV	CX,%WORDLEN%
		CMP	AX,CX
		JNE	%LOOP%	; Fast path
		PUSH	BX
		PUSH	AX
		LEA	AX,[BX.HA_NAME]
		PUSH	AX
		PUSH	CX
		PUSH	%WORD%
		CALL	CMP_WORD
		ADD	SP,8
		POP	BX
		TEST	AX,AX
		JE	%LOOP%
	%FND%:
		MOV	AX,BX
		JMP	SHORT %END%
	%NOTF%:
		XOR	AX,AX
	%END%:
	}
 }
}

{(PROC(NEED_HASH))
 {(ARG(HASH))
  {(LOCAL(SYM))
	{(WHILE)
		MOV	BX,%HASH%
		MOV	BX,[BX.HA_SYM]
		TEST	BX,BX
		JE	%DONE%
		CMP	[BX.SY_NEED],0
		JNE	%DONE%
		MOV	AX,BX
		MOV	%SYM%,AX
		{(WHILE)
		%LOOP%:
			MOV	[BX.SY_NEED],1
			MOV	BX,[BX.SY_NEXT]
			CMP	BX,AX
			JNE	%LOOP%
		}
	%LOOP%:
		PUSH	BX
		MOV	BX,[BX.SY_REL]
		{(WHILE)
			TEST	BX,BX
			JE	%DONE%
		%LOOP%:
			PUSH	BX
			PUSH	[BX.RE_HASH]
			CALL	NEED_HASH
			ADD	SP,2
			POP	BX
			MOV	BX,[BX.RE_NEXT]
			TEST	BX,BX
			JNE	%LOOP%
		%DONE%:
		}
		POP	BX
		MOV	BX,[BX.SY_NEXT]
		CMP	BX,%SYM%
		JNE	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(NEED_WORD))
 {(ARG(WORD,WORDLEN))
	PUSH	%WORDLEN%
	PUSH	%WORD%
	CALL	FIND_NAME
	ADD	SP,4
	{(IF)
		TEST	AX,AX
		JE	%ENDIF%
		PUSH	AX
		CALL	NEED_HASH
		ADD	SP,2
	%ENDIF%:
	}
 }
}

{(PROC(ADD_STOR_ALLOC))
 {(ARG(LEN))
	MOV	CX,%LEN%
	MOV	DX,[STORLEN]
	MOV	AX,STORSIZE
	SUB	AX,DX
	CMP	AX,CX
	{(IF)
		JNC	%ENDIF%
		MOV	AX,OFFSET MSG_OUT_OF_MEMORY
		PUSH	AX
		CALL	ERR_EXIT
		POP	AX
	%ENDIF%:
	}
	MOV	AX,OFFSET STOR
	ADD	AX,DX
	ADD	DX,CX
	MOV	[STORLEN],DX
 }
}

{(PROC(ADD_STOR))
 {(ARG(S,BUF,LEN))
  {(LOCAL(HASH))
	MOV	WORD PTR %HASH%,0
	MOV	AX,%LEN%
	{(IF)
		TEST	AX,AX
		JE	%ENDIF%
		{(IF)
			PUSH	AX
			PUSH	%BUF%
			CALL	FIND_NAME
			ADD	SP,4
			TEST	AX,AX
			JE	%ELSE%
			MOV	%HASH%,AX
			JMP	%ENDIF%
		%ELSE%:
			MOV	AX,%LEN%
			ADD	AX,SIZE S_HASH-1
			PUSH	AX
			CALL	ADD_STOR_ALLOC
			ADD	SP,2
			MOV	%HASH%,AX
			PUSH	%LEN%
			PUSH	%BUF%
			CALL	HASHADR
			ADD	SP,4
			MOV	BX,AX
			MOV	AX,%HASH%
			MOV	CX,[BX]
			MOV	[BX],AX
			MOV	BX,AX
			MOV	[BX.HA_NEXT],CX
			MOV	[BX.HA_SYM],0
			XOR	CX,CX
			MOV	CL,%LEN%
			MOV	[BX.HA_NLEN],CL
			LEA	DI,[BX.HA_NAME]
			CLD
			MOV	SI,%BUF%
			REP	MOVSB
		%ENDIF%:
		}
	%ENDIF%:
	}
	MOV	AX,%S%
	{(IF)
		TEST	AX,STOR_BEGIN OR STOR_END
		JE	%ENDIF%
		MOV	[SYMCUR],0
	%ENDIF%:
	}
	{(IF)
		TEST	AX,STOR_REL
		JE	%ELSE%
		MOV	AX,SIZE S_REL
		PUSH	AX
		CALL	ADD_STOR_ALLOC
		ADD	SP,2
		MOV	BX,[SYMCUR]
		{(IF)
			TEST	BX,BX
			JE	%THEN%
			CMP	WORD PTR %HASH%,0
			JNE	%ENDIF%
		%THEN%:
			MOV	AX,OFFSET MSG_INTERNAL_ERROR
			PUSH	AX
			CALL	ERR_EXIT
			POP	AX
		%ENDIF%:
		}
		MOV	CX,[BX.SY_REL]
		MOV	[BX.SY_REL],AX
		MOV	BX,AX
		MOV	[BX.RE_NEXT],CX
		MOV	AX,%HASH%
		MOV	[BX.RE_HASH],AX
		JMP	%ENDIF%
	%ELSE%:
		TEST	AX,STOR_SYM
		JE	%ENDIF%
		MOV	AX,SIZE S_SYM
		PUSH	AX
		CALL	ADD_STOR_ALLOC
		ADD	SP,2
		MOV	BX,AX
		MOV	SI,[SYMCUR]
		{(IF)
			TEST	SI,SI
			JNE	%ELSE%
			MOV	[BX.SY_NEXT],AX
			JMP	%ENDIF%
		%ELSE%:
			MOV	CX,[SI.SY_NEXT]
			MOV	[BX.SY_NEXT],CX
			MOV	[SI.SY_NEXT],AX
		%ENDIF%:
		}
		MOV	[SYMCUR],AX
		XOR	CX,CX
		MOV	[BX.SY_REL],CX
		MOV	[BX.SY_NEED],CL
		MOV	BX,%HASH%
		{(IF)
			TEST	BX,BX
			JE	%THEN%
			CMP	[BX.HA_SYM],0
			JE	%ENDIF%
		%THEN%:
			MOV	AX,OFFSET MSG_INTERNAL_ERROR
			PUSH	AX
			CALL	ERR_EXIT
			POP	AX
		%ENDIF%:
		}
		MOV	[BX.HA_SYM],AX
	%ENDIF%:
	}
  }
 }
}

{(PROC(FIND_SYMS))
 {(ARG(BUF))
  {(LOCAL(WORD,LEN))
	{(WHILE)
	%LOOP%:
		MOV	AX,%BUF%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN%,AX
		TEST	AX,AX
		JE	%DONE%
		PUSH	%LEN%
		PUSH	%WORD%
		CALL	FIND_NAME
		ADD	SP,4
		{(IF)
			TEST	AX,AX
			JE	%ENDIF%
			MOV	BX,AX
			MOV	AX,[BX.HA_SYM]
			TEST	AX,AX
			JE	%ENDIF%
			MOV	AX,1
			JMP	SHORT %DONE%
		%ENDIF%:
		}
		MOV	AX,%WORD%
		ADD	AX,%LEN%
		MOV	%BUF%,AX
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(NEED_WORDS))
 {(ARG(BUF))
  {(LOCAL(WORD,LEN))
	{(WHILE)
	%LOOP%:
		MOV	AX,%BUF%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN%,AX
		TEST	AX,AX
		JE	%DONE%
		PUSH	%LEN%
		PUSH	%WORD%
		CALL	NEED_WORD
		ADD	SP,4
		MOV	AX,%WORD%
		ADD	AX,%LEN%
		MOV	%BUF%,AX
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(ADD_REL_WORDS))
 {(ARG(BUF))
  {(LOCAL(WORD,LEN))
	{(WHILE)
	%LOOP%:
		MOV	AX,%BUF%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN%,AX
		TEST	AX,AX
		JE	%DONE%
		PUSH	%LEN%
		PUSH	%WORD%
		MOV	AX,STOR_REL
		PUSH	AX
		CALL	ADD_STOR
		ADD	SP,6
		MOV	AX,%WORD%
		ADD	AX,%LEN%
		MOV	%BUF%,AX
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(PASS1))
 {(ARG(BUF,WORD,LEN,WORD2,LEN2))
  {((RET))
	{(IF)
		CMP	WORD PTR IN_STRUC,0
		{((SKIP))
			JNE	%SKIP%
			JMP	%ENDIF%
		%SKIP%:
		}
		{(IF)
			MOV	AX,4
			PUSH	AX
			MOV	AX,OFFSET STR_ENDS
			PUSH	AX
			PUSH	%LEN2%
			PUSH	%WORD2%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ELSE%
			MOV	WORD PTR [IN_STRUC],0
			PUSH	%BUF%
			CALL	ADD_REL_WORDS
			POP	AX
			XOR	AX,AX
			PUSH	AX
			PUSH	AX
			MOV	AX,STOR_END
			PUSH	AX
			CALL	ADD_STOR
			ADD	SP,6
			JMP	%ENDIF%
		%ELSE%:
			{(IF)
				MOV	AX,2
				PUSH	AX
				MOV	AX,OFFSET STR_DB
				PUSH	AX
				PUSH	%LEN2%
				PUSH	%WORD2%
				CALL	CMP_WORD
				ADD	SP,8
				TEST	AX,AX
				JNE	%THEN%
				MOV	AX,2
				PUSH	AX
				MOV	AX,OFFSET STR_DW
				PUSH	AX
				PUSH	%LEN2%
				PUSH	%WORD2%
				CALL	CMP_WORD
				ADD	SP,8
				TEST	AX,AX
				JNE	%THEN%
				MOV	AX,2
				PUSH	AX
				MOV	AX,OFFSET STR_DD
				PUSH	AX
				PUSH	%LEN2%
				PUSH	%WORD2%
				CALL	CMP_WORD
				ADD	SP,8
				TEST	AX,AX
				JE	%ENDIF%
			%THEN%:
				{(IF)
					PUSH	%LEN%
					PUSH	%WORD%
					CALL	FIND_NAME
					ADD	SP,4
					TEST	AX,AX
					JE	%ENDIF%
					MOV	BX,AX
					MOV	AX,[BX.HA_SYM]
					TEST	AX,AX
					JE	%ENDIF%
					MOV	AX,OFFSET MSG_STRUC2
					PUSH	AX
					CALL	ERR_EXIT
					POP	AX
				%ENDIF%:
				}
				PUSH	%LEN%
				PUSH	%WORD%
				MOV	AX,STOR_SYM
				PUSH	AX
				CALL	ADD_STOR
				ADD	SP,6
			%ENDIF%:
			}
			PUSH	%BUF%
			CALL	ADD_REL_WORDS
			POP	AX
		%ENDIF%:
		}
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,5
		PUSH	AX
		MOV	AX,OFFSET STR_STRUC
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
		MOV	WORD PTR [IN_STRUC],1
		{(IF)
			PUSH	%LEN%
			PUSH	%WORD%
			CALL	FIND_NAME
			ADD	SP,4
			TEST	AX,AX
			JE	%ENDIF%
			MOV	BX,AX
			MOV	AX,[BX.HA_SYM]
			TEST	AX,AX
			JE	%ENDIF%
			MOV	AX,OFFSET MSG_STRUC
			PUSH	AX
			CALL	ERR_EXIT
			POP	AX
		%ENDIF%:
		}
		PUSH	%LEN%
		PUSH	%WORD%
		MOV	AX,STOR_SYM OR STOR_BEGIN
		PUSH	AX
		CALL	ADD_STOR
		ADD	SP,6
		PUSH	%BUF%
		CALL	ADD_REL_WORDS
		POP	AX
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,3
		PUSH	AX
		MOV	AX,OFFSET STR_EQU
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JNE	%THEN%
		MOV	AX,1
		PUSH	AX
		MOV	AX,OFFSET STR_EQUAL
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
	%THEN%:
		{(IF)
			CMP	WORD PTR %LEN%,8
			JNB	%ELSE%
			PUSH	%BUF%
			CALL	FIND_SYMS
			ADD	SP,2
			TEST	AX,AX
			JNE	%ELSE%
			JMP	%ENDIF%
		%ELSE%:
			{(IF)
				PUSH	%LEN%
				PUSH	%WORD%
				CALL	FIND_NAME
				ADD	SP,4
				TEST	AX,AX
				JE	%ELSE%
				MOV	BX,AX
				MOV	AX,[BX.HA_SYM]
				TEST	AX,AX
				JE	%ELSE%
				PUSH	%LEN%
				PUSH	%WORD%
				CALL	NEED_WORD
				ADD	SP,4
				JMP	%ENDIF%
			%ELSE%:
				PUSH	%LEN%
				PUSH	%WORD%
				MOV	AX,STOR_SYM OR STOR_BEGIN
				PUSH	AX
				CALL	ADD_STOR
				ADD	SP,6
				PUSH	%BUF%
				CALL	ADD_REL_WORDS
				POP	AX
				XOR	AX,AX
				PUSH	AX
				PUSH	AX
				MOV	AX,STOR_END
				PUSH	AX
				CALL	ADD_STOR
				ADD	SP,6
			%ENDIF%:
			}
		%ENDIF%:
		}
	%ENDIF%:
	}
  %RET%:
  }
 }
}

{(PROC(PASS2))
 {(ARG(BUF,WORD,LEN,WORD2,LEN2))
  {((RET))
	MOV	AX,5
	PUSH	AX
	MOV	AX,OFFSET STR_BREAK
	PUSH	AX
	PUSH	%LEN%
	PUSH	%WORD%
	CALL	CMP_WORD
	ADD	SP,8
	TEST	AX,AX
	{((SKIP))
		JE	%SKIP%
		JMP	%RET%
	%SKIP%:
	}
	{(IF)
		CMP	WORD PTR [IN_STRUC],0
		JE	%ENDIF%
		{(IF)
			MOV	AX,4
			PUSH	AX
			MOV	AX,OFFSET STR_ENDS
			PUSH	AX
			PUSH	%LEN2%
			PUSH	%WORD2%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ENDIF%
			MOV	WORD PTR [IN_STRUC],0
		%ENDIF%:
		}
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,5
		PUSH	AX
		MOV	AX,OFFSET STR_STRUC
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
		MOV	WORD PTR [IN_STRUC],1
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,3
		PUSH	AX
		MOV	AX,OFFSET STR_EQU
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JNE	%THEN%
		MOV	AX,1
		PUSH	AX
		MOV	AX,OFFSET STR_EQUAL
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
	%THEN%:
		JMP	%RET%
	%ENDIF%:
	}
	PUSH	%BUF%
	CALL	NEED_WORDS
	POP	AX
  %RET%:
  }
 }
}

{(PROC(PASS3))
 {(ARG(BUF,WORD,LEN,WORD2,LEN2))
  {(LOCAL(UNUSED))
   {((RET))
	MOV	WORD PTR %UNUSED%,0
	{(IF)
		CMP	WORD PTR [IN_STRUC],0
		JE	%ENDIF%
		{(IF)
			CMP	WORD PTR [IN_STRUC],2
			JNE	%ENDIF%
			MOV	WORD PTR %UNUSED%,1
		%ENDIF%:
		}
		{(IF)
			MOV	AX,4
			PUSH	AX
			MOV	AX,OFFSET STR_ENDS
			PUSH	AX
			PUSH	%LEN2%
			PUSH	%WORD2%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ENDIF%
			MOV	WORD PTR [IN_STRUC],0
		%ENDIF%:
		}
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,5
		PUSH	AX
		MOV	AX,OFFSET STR_STRUC
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
		MOV	WORD PTR [IN_STRUC],1
		PUSH	%LEN%
		PUSH	%WORD%
		CALL	FIND_NAME
		ADD	SP,4
		{(IF)
			TEST	AX,AX
			JE	%ENDIF%
			MOV	BX,AX
			MOV	BX,[BX.HA_SYM]
			TEST	BX,BX
			JE	%ENDIF%
			CMP	[BX.SY_NEED],0
			JNE	%ENDIF%
			MOV	WORD PTR [IN_STRUC],2
			MOV	WORD PTR %UNUSED%,1
		%ENDIF%:
		}
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,3
		PUSH	AX
		MOV	AX,OFFSET STR_EQU
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JNE	%THEN%
		MOV	AX,1
		PUSH	AX
		MOV	AX,OFFSET STR_EQUAL
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
	%THEN%:
		PUSH	%LEN%
		PUSH	%WORD%
		CALL	FIND_NAME
		ADD	SP,4
		{(IF)
			TEST	AX,AX
			JE	%ENDIF%
			MOV	BX,AX
			MOV	BX,[BX.HA_SYM]
			TEST	BX,BX
			JE	%ENDIF%
			CMP	[BX.SY_NEED],0
			JNE	%ENDIF%
			MOV	WORD PTR %UNUSED%,1
		%ENDIF%:
		}
	%ENDIF%:
	}
   %RET%:
	{(IF)
		CMP	WORD PTR %UNUSED%,0
		JE	%ENDIF%
		MOV	AX,OFFSET STR_UNUSED
		PUSH	AX
		CALL	PRINT
		POP	AX
	%ENDIF%:
	}
	PUSH	%BUF%
	CALL	PRINT
	POP	AX
	MOV	AX,OFFSET STR_CRLF
	PUSH	AX
	CALL	PRINT
	POP	AX
   }
  }
 }
}

{(PROC(PASS))
 {(ARG(BUF,BUFLEN,FP,HANDLER))
  {(LOCAL(FP2,WORD,LEN,WORD2,LEN2,FILENAME))
	{(WHILE)
	%LOOP%:
		PUSH	%BUFLEN%
		PUSH	%BUF%
		PUSH	%FP%
		CALL	GET_LINE
		ADD	SP,6
		TEST	AX,AX
		{((SKIP))
			JNE	%SKIP%
			JMP	%DONE%
		%SKIP%:
		}
		MOV	AX,%BUF%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN%,AX
		{(IF)
			MOV	AX,7
			PUSH	AX
			MOV	AX,OFFSET STR_INCLUDE
			PUSH	AX
			PUSH	%LEN%
			PUSH	%WORD%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ENDIF%
			MOV	AX,%WORD%
			ADD	AX,%LEN%
			PUSH	AX
			CALL	GET_WORD_START
			ADD	SP,2
			PUSH	AX
			CALL	GET_STRING
			ADD	SP,2
			MOV	%FILENAME%,AX
			PUSH	AX
			CALL	OPEN_FOR_READ
			ADD	SP,2
			MOV	%FP2%,AX
			{(IF)
				TEST	AX,AX
				JNE	%ENDIF%
				MOV	AX,OFFSET MSG_OPEN_ERROR
				PUSH	AX
				CALL	ERR_EXIT
				POP	AX
			%ENDIF%:
			}
			PUSH	%HANDLER%
			PUSH	%FP2%
			PUSH	%BUFLEN%
			PUSH	%BUF%
			CALL	PASS
			ADD	SP,8
			PUSH	%FP2%
			CALL	CLOSE
			POP	AX
			JMP	%LOOP%
		%ENDIF%:
		}
		MOV	AX,%WORD%
		ADD	AX,%LEN%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD2%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN2%,AX
		PUSH	AX
		PUSH	%WORD2%
		PUSH	%LEN%
		PUSH	%WORD%
		PUSH	%BUF%
		CALL	%HANDLER%
		ADD	SP,10
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(MAIN))
 {(ARG(FILENAME))
  {(LOCAL(FP))
	PUSH	%FILENAME%
	CALL	OPEN_FOR_READ
	ADD	SP,2
	MOV	%FP%,AX
	{(IF)
		TEST	AX,AX
		JNE	%ENDIF%
		MOV	AX,OFFSET MSG_OPEN_ERROR
		PUSH	AX
		CALL	ERR_EXIT
		POP	AX
	%ENDIF%:
	}
	MOV	AX,OFFSET PASS1
	PUSH	AX
	PUSH	%FP%
	MOV	AX,SIZEOF_BUF
	PUSH	AX
	MOV	AX,OFFSET BUF
	PUSH	AX
	CALL	PASS
	ADD	SP,8
	PUSH	%FP%
	CALL	REWIND
	POP	AX
	MOV	AX,OFFSET PASS2
	PUSH	AX
	PUSH	%FP%
	MOV	AX,SIZEOF_BUF
	PUSH	AX
	MOV	AX,OFFSET BUF
	PUSH	AX
	CALL	PASS
	ADD	SP,8
	PUSH	%FP%
	CALL	REWIND
	POP	AX
	MOV	AX,OFFSET PASS3
	PUSH	AX
	PUSH	%FP%
	MOV	AX,SIZEOF_BUF
	PUSH	AX
	MOV	AX,OFFSET BUF
	PUSH	AX
	CALL	PASS
	ADD	SP,8
	PUSH	%FP%
	CALL	CLOSE
	POP	AX
	MOV	AX,OFFSET STR_END1
	PUSH	AX
	CALL	PRINT
	POP	AX
	PUSH	[STORLEN]
	CALL	PRINT_VALUE
	POP	AX
	MOV	AX,OFFSET STR_END2
	PUSH	AX
	CALL	PRINT
	POP	AX
	XOR	AX,AX
  }
 }
}

;TYPE
;CHAR_SEPARATOR	EQU	0
;CHAR_COMMENT	EQU	2
;CHAR_STRING	EQU	3
;CHAR_SYMBOL	EQU	4
;CHAR_OPERATOR	EQU	5
; 2 COMMENT	3BH
; 3 STRING	22H OR 27H
; 0 SEPARATOR	00H-20H
; 5 OPERATOR	21H OR 23H OR 26H-2FH OR 3AH-3EH OR 5BH-5DH OR 7BH-7DH
; 4 SYMBOL
;TYPE MATRIX
; NEXT NOW 0 2 3 4 5
; 0        0 2 3 0 0
; 2        2 2 3 2 2
; 3        3 2 0 3 3
; 4        4 2 3 4 4
; 5        5 2 3 5 5
TYPETBL	LABEL	BYTE
	;;   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	DB 00H,00H,02H,03H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	DB 00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	DB 02H,50H,32H,53H,42H,42H,50H,30H,50H,50H,50H,50H,50H,50H,50H,50H
	DB 43H,40H,42H,40H,43H,43H,40H,40H,40H,40H,50H,20H,50H,50H,50H,40H
	DB 44H,40H,42H,43H,44H,44H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 45H,40H,42H,43H,45H,45H,40H,40H,40H,40H,40H,50H,40H,50H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,50H,40H,50H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
MSG_TOOLONG		DB	'TOO LONG',0
MSG_INTERNAL_ERROR	DB	'INTERNAL ERROR',0
MSG_OPEN_ERROR		DB	'OPEN ERROR',0
MSG_WRITE_ERROR		DB	'WRITE ERROR',0
MSG_OUT_OF_MEMORY	DB	'OUT OF MEMORY',0
MSG_STRUC		DB	'STRUC NAME ALREADY EXISTS',0
MSG_STRUC2		DB	'STRUC MEMBER NAME ALREADY EXISTS',0
STR_CRLF		DB	13,10,0
STR_ENDS		DB	'ENDS'
STR_DB			DB	'DB'
STR_DW			DB	'DW'
STR_DD			DB	'DD'
STR_STRUC		DB	'STRUC'
STR_EQU			DB	'EQU'
STR_EQUAL		DB	'='
STR_BREAK		DB	'BREAK'
STR_INCLUDE		DB	'INCLUDE'
STR_UNUSED		DB	';UNUSED;',0
STR_END1		DB	'; (',0
STR_END2		DB	')',13,10,0
STORLEN			DW	0
IN_STRUC		DW	0

STACK	EQU	$+4096
BUF	EQU	$+4096
STOR	EQU	BUF+SIZEOF_BUF

A	ENDS
	END	START
