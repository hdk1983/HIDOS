; Copyright 2022 Hideki EIRAKU <hdk_2@users.sourceforge.net>
; 
; Permission is hereby granted, free of charge, to any person obtaining
; a copy of this software and associated documentation files (the
; "Software"), to deal in the Software without restriction, including
; without limitation the rights to use, copy, modify, merge, publish,
; distribute, sublicense, and/or sell copies of the Software, and to
; permit persons to whom the Software is furnished to do so, subject to
; the following conditions:
; 
; The above copyright notice and this permission notice shall be
; included in all copies or substantial portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
{(IF(THEN,ELSE,ENDIF))}                                                         
{(WHILE(LOOP,DO,DONE))}

A	SEGMENT
	ASSUME	CS:A,DS:A,ES:A,SS:A
	ORG	100H
START:
	CMP	SP,OFFSET STOR+STORSIZE
	JAE	STACK_OK
	RET
STACK_OK:
	MOV	SP,OFFSET STACK
	MOV	BX,80H
	MOV	AL,[BX]
	CBW
	INC	BX
	ADD	BX,AX
	MOV	BYTE PTR [BX],0
	MOV	AX,82H
	PUSH	AX
	CALL	MAIN
	MOV	AH,4CH
	INT	21H

SIZEOF_BUF	EQU	128
STORSIZE	EQU	32768
STOR_SYM	EQU	1
STOR_BEGIN	EQU	2
STOR_END	EQU	4
STOR_REL	EQU	8
STOR_NEED	EQU	16

CHAR_SEPARATOR	EQU	0
CHAR_COMMENT	EQU	2
CHAR_STRING	EQU	3
CHAR_SYMBOL	EQU	4
CHAR_OPERATOR	EQU	5
CHAR_SYMOPE_BIT	EQU	4

{(PROC(ERR_EXIT))
 {(ARG(MESSAGE))
	MOV	BX,%MESSAGE%
	MOV	DX,BX
	{(WHILE)
	%LOOP%:
		CMP	BYTE PTR [BX],0
		JE	%DONE%
		INC	BX
		JMP	%LOOP%
	%DONE%:
	}
	MOV	CX,BX
	SUB	CX,DX
	MOV	BX,2
	MOV	AH,40H
	INT	21H
	MOV	DX,OFFSET STR_CRLF
	MOV	CX,2
	MOV	BX,2
	MOV	AH,40H
	INT	21H
	MOV	AX,4C01H
	INT	21H
 }
}

{(PROC(OPEN_FOR_READ))
 {(ARG(FILENAME))
	MOV	DX,%FILENAME%
	MOV	AX,3D00H
	INT	21H
	{(IF)
		JNC	%ENDIF%
		XOR	AX,AX
	%ENDIF%:
	}
 }
}

{(PROC(CLOSE))
 {(ARG(FP))
	MOV	BX,%FP%
	MOV	AH,3EH
	INT	21H
 }
}

{(PROC(REWIND))
 {(ARG(FP))
	XOR	DX,DX
	XOR	CX,CX
	MOV	BX,%FP%
	MOV	AX,4200H
	INT	21H
 }
}

{(PROC(PRINT))
 {(ARG(STR))
	MOV	BX,%STR%
	MOV	DX,BX
	{(WHILE)
	%LOOP%:
		CMP	BYTE PTR [BX],0
		JE	%DONE%
		INC	BX
		JMP	%LOOP%
	%DONE%:
	}
	MOV	CX,BX
	SUB	CX,DX
	{(IF)
		JE	%ENDIF%
		MOV	BX,1
		MOV	AH,40H
		INT	21H
		{(IF)
			JC	%THEN%
			CMP	AX,CX
			JE	%ENDIF%
		%THEN%:
			MOV	AX,OFFSET MSG_WRITE_ERROR
			PUSH	AX
			CALL	ERR_EXIT
			POP	AX
		%ENDIF%:
		}
	%ENDIF%:
	}
 }
}

{(PROC(PRINT_VALUE))
 {(ARG(VALUE))
	MOV	AX,%VALUE%
	{(IF)
		MOV	CX,10
		CMP	AX,CX
		JB	%ENDIF%
		XOR	DX,DX
		DIV	CX
		MOV	%VALUE%,DX
		PUSH	AX
		CALL	PRINT_VALUE
		POP	AX
	%ENDIF%:
	}
	LEA	BX,%VALUE%
	ADD	BYTE PTR [BX],'0'
	PUSH	BX
	CALL	PRINT
	POP	AX
 }
}

{(PROC(GET_LINE))
 {(ARG(FP,BUF,BUFSIZE))
  {(LOCAL(C,I,GETCBUF))
	MOV	WORD PTR %I%,0
	{(WHILE)
	%LOOP%:
		MOV	AX,%I%
		CMP	AX,%BUFSIZE%
		JB	%DO%
		MOV	AX,OFFSET MSG_TOOLONG
		PUSH	AX
		CALL	ERR_EXIT
		POP	AX
	%DO%:
		{(IF)
			LEA	DX,%GETCBUF%
			MOV	CX,1
			MOV	BX,%FP%
			MOV	AH,3FH
			INT	21H
			JC	%THEN%
			CMP	AX,1
			MOV	AL,%GETCBUF%
			JE	%ENDIF%
		%THEN%:
			MOV	AX,-1
		%ENDIF%:
		}
		AND	AL,7FH
		CMP	AL,13
		JE	%DO%
		{(IF)
			CMP	AL,26
			JNE	%ENDIF%
			MOV	AX,-1
		%ENDIF%:
		}
		CMP	AL,0
		JE	%DO%
		{(IF)
			TEST	AX,AX
			JS	%THEN%
			CMP	AL,10
			JNE	%ENDIF%
		%THEN%:
			MOV	BX,%BUF%
			ADD	BX,%I%
			MOV	BYTE PTR [BX],0
			{(IF)
				CMP	WORD PTR %I%,0
				JA	%ELSE%
				TEST	AX,AX
				JNS	%ELSE%
				XOR	AX,AX
				JMP	SHORT %DONE%
			%ELSE%:
				MOV	AX,1
				JMP	SHORT %DONE%
			}
		%ENDIF%:
		}
		MOV	BX,%BUF%
		ADD	BX,%I%
		MOV	[BX],AL
		INC	WORD PTR %I%
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(GET_WORD_START))
 {(ARG(BUF))
	MOV	DL,CHAR_SEPARATOR
	MOV	SI,%BUF%
	CLD
	XOR	AX,AX
	MOV	BX,OFFSET TYPETBL
	{(WHILE)
	%LOOP%:
		LODSB
		CMP	AL,0
		JE	%DONE%
		XLAT
		AND	AL,0F0H
		OR	AL,DL
		XLAT
		AND	AL,0FH
		MOV	DL,AL
		TEST	AL,CHAR_SYMOPE_BIT
		JE	%LOOP%
	%DONE%:
	}
	LEA	AX,[SI-1]
 }
}

{(PROC(GET_WORD_LEN))
 {(ARG(BUF))
	XOR	CX,CX
	MOV	SI,%BUF%
	XOR	AX,AX
	CLD
	LODSB
	{(IF)
		CMP	AL,0
		JE	%ENDIF%
		MOV	BX,OFFSET TYPETBL
		XLAT
		AND	AL,0F0H
		XLAT
		AND	AL,0FH
		MOV	DL,AL
		DEC	CX
		{(IF)
			TEST	AL,CHAR_SYMOPE_BIT
			JE	%ENDIF%
			{(WHILE)
			%LOOP%:
				LODSB
				CMP	AL,0
				JE	%DONE%
				XLAT
				AND	AL,0F0H
				OR	AL,DL
				XLAT
				AND	AL,0FH
				CMP	AL,DL
				LOOPE	%LOOP%
				INC	CX
			%DONE%:
			}
		%ENDIF%:
		}
	%ENDIF%:
	}
	NEG	CX
	MOV	AX,CX
 }
}

{(PROC(TO_UPPER))
 {(ARG(C))
	MOV	AX,%C%
	{(IF)
		CMP	AL,'a'
		JB	%ENDIF%
		CMP	AL,'z'
		JA	%ENDIF%
		SUB	AL,'a'-'A'
	%ENDIF%:
	}
 }
}

{(PROC(CMP_WORD))
 {(ARG(S1,S1LEN,S2,S2LEN))
	{((BEGIN,END))
		MOV	AX,%S1LEN%
		CMP	AX,%S2LEN%
		JE	%BEGIN%
		XOR	AX,AX
		JMP	SHORT %END%
	%BEGIN%:
		MOV	AX,1
		CMP	WORD PTR %S1LEN%,0
		JE	%END%
		MOV	BX,%S1%
		XOR	AX,AX
		MOV	AL,[BX]
		PUSH	AX
		CALL	TO_UPPER
		ADD	SP,2
		PUSH	AX
		MOV	BX,%S2%
		XOR	AX,AX
		MOV	AL,[BX]
		PUSH	AX
		CALL	TO_UPPER
		ADD	SP,2
		POP	BX
		INC	WORD PTR %S1%
		INC	WORD PTR %S2%
		{(IF)
			CMP	AX,BX
			JE	%ENDIF%
			XOR	AX,AX
			JMP	SHORT %END%
		%ENDIF%:
		}
		DEC	WORD PTR %S1LEN%
		JMP	%BEGIN%
	%END%:
	}
 }
}

{(PROC(GET_STRING))
 {(ARG(BUF))
  {(LOCAL(I))
	MOV	WORD PTR %I%,0
	{(WHILE)
	%LOOP%:
		MOV	BX,%BUF%
		ADD	BX,%I%
		XOR	AX,AX
		MOV	AL,[BX]
		CMP	AL,0
		JE	%DONE%
		{(IF)
			CMP	AL,' '
			JA	%ENDIF%
			MOV	BYTE PTR [BX],0
			JMP	SHORT %DONE%
		%ENDIF%:
		}
		PUSH	AX
		CALL	TO_UPPER
		ADD	SP,2
		MOV	BX,%BUF%
		ADD	BX,%I%
		MOV	[BX],AL
		INC	WORD PTR %I%
		JMP	%LOOP%
	%DONE%:
	}
	MOV	AX,%BUF%
  }
 }
}

{(PROC(STOR_GET))
 {(ARG(OFF,S,C))
  {(LOCAL(LEN))
	MOV	AX,%OFF%
	ADD	AX,2
	{(IF)
		CMP	AX,[STORLEN]
		JB	%ELSE%
		MOV	AX,0FFFFH
		JMP	SHORT %ENDIF%
	%ELSE%:
		MOV	AX,OFFSET STOR
		ADD	AX,%OFF%
		MOV	BX,%S%
		MOV	[BX],AX
		INC	WORD PTR %OFF%
		MOV	BX,OFFSET STOR
		ADD	BX,%OFF%
		XOR	AX,AX
		MOV	AL,[BX]
		MOV	%LEN%,AX
		INC	WORD PTR %OFF%
		MOV	AX,OFFSET STOR
		ADD	AX,%OFF%
		MOV	BX,%C%
		MOV	[BX],AX
		MOV	AX,%LEN%
	%ENDIF%:
	}
  }
 }
}

{(PROC(STOR_NEXT))
 {(ARG(OFF,LEN))
	MOV	AX,%OFF%
	ADD	AX,2
	ADD	AX,%LEN%
 }
}

{(PROC(FIND_SYM))
 {(ARG(WORD,WORDLEN))
  {(LOCAL(OFF,LEN,S,C))
	MOV	WORD PTR %OFF%,0
	{(WHILE)
	%LOOP%:
		LEA	AX,%C%
		PUSH	AX
		LEA	AX,%S%
		PUSH	AX
		PUSH	%OFF%
		CALL	STOR_GET
		ADD	SP,6
		MOV	%LEN%,AX
		INC	AX
		JE	%DONE%
		{(IF)
			MOV	BX,%S%
			TEST	BYTE PTR [BX],STOR_SYM
			JE	%ENDIF%
			PUSH	%LEN%
			PUSH	%C%
			PUSH	%WORDLEN%
			PUSH	%WORD%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ENDIF%
			XOR	AX,AX
			MOV	BX,%S%
			MOV	AL,[BX]
			JMP	SHORT %DONE%
		%ENDIF%:
		}
		PUSH	%LEN%
		PUSH	%OFF%
		CALL	STOR_NEXT
		ADD	SP,4
		MOV	%OFF%,AX
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(NEED_WORD))
 {(ARG(WORD,WORDLEN))
  {(LOCAL(OFF,LEN,S,C,OFF_BEGIN))
	MOV	WORD PTR %OFF_BEGIN%,-1
	MOV	WORD PTR %OFF%,0
	{((LOOP1,FOUND,END))
	%LOOP1%:
		LEA	AX,%C%
		PUSH	AX
		LEA	AX,%S%
		PUSH	AX
		PUSH	%OFF%
		CALL	STOR_GET
		ADD	SP,6
		MOV	%LEN%,AX
		INC	AX
		{((SKIP))
			JNE	%SKIP%
			JMP	%END%
		%SKIP%:
		}
		MOV	BX,%S%
		{(IF)
			TEST	BYTE PTR [BX],STOR_BEGIN
			JE	%ENDIF%
			CMP	WORD PTR %OFF_BEGIN%,-1
			JNE	%ENDIF%
			MOV	AX,%OFF%
			MOV	%OFF_BEGIN%,AX
		%ENDIF%:
		}
		{(IF)
			TEST	BYTE PTR [BX],STOR_END
			JE	%ENDIF%
			MOV	WORD PTR %OFF_BEGIN%,-1
		%ENDIF%:
		}
		{(IF)
			TEST	BYTE PTR [BX],STOR_SYM
			JE	%ENDIF%
			PUSH	%LEN%
			PUSH	%C%
			PUSH	%WORDLEN%
			PUSH	%WORD%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ENDIF%
			MOV	BX,%S%
			TEST	BYTE PTR [BX],STOR_NEED
			JE	%FOUND%
			JMP	%END%
		%ENDIF%:
		}
		PUSH	%LEN%
		PUSH	%OFF%
		CALL	STOR_NEXT
		ADD	SP,4
		MOV	%OFF%,AX
		JMP	%LOOP1%
	%FOUND%:
		{(IF)
			CMP	WORD PTR %OFF_BEGIN%,-1
			JNE	%ENDIF%
			MOV	AX,OFFSET MSG_INTERNAL_ERROR
			PUSH	AX
			CALL	ERR_EXIT
			POP	AX
		%ENDIF%:
		}
		MOV	AX,%OFF_BEGIN%
		MOV	%OFF%,AX
		{(WHILE)
		%LOOP%:
			LEA	AX,%C%
			PUSH	AX
			LEA	AX,%S%
			PUSH	AX
			PUSH	%OFF%
			CALL	STOR_GET
			ADD	SP,6
			MOV	%LEN%,AX
			INC	AX
			JE	%DONE%
			MOV	BX,%S%
			{(IF)
				TEST	BYTE PTR [BX],STOR_SYM
				JE	%ENDIF%
				OR	BYTE PTR [BX],STOR_NEED
			%ENDIF%:
			}
			TEST	BYTE PTR [BX],STOR_END
			JNE	%DONE%
			PUSH	%LEN%
			PUSH	%OFF%
			CALL	STOR_NEXT
			ADD	SP,4
			MOV	%OFF%,AX
			JMP	%LOOP%
		%DONE%:
		}
		MOV	AX,%OFF_BEGIN%
		MOV	%OFF%,AX
		{(WHILE)
		%LOOP%:
			LEA	AX,%C%
			PUSH	AX
			LEA	AX,%S%
			PUSH	AX
			PUSH	%OFF%
			CALL	STOR_GET
			ADD	SP,6
			MOV	%LEN%,AX
			INC	AX
			JE	%DONE%
			MOV	BX,%S%
			{(IF)
				TEST	BYTE PTR [BX],STOR_REL
				JE	%ENDIF%
				PUSH	%LEN%
				PUSH	%C%
				CALL	NEED_WORD
				ADD	SP,4
			%ENDIF%:
			}
			MOV	BX,%S%
			TEST	BYTE PTR [BX],STOR_END
			JNE	%DONE%
			PUSH	%LEN%
			PUSH	%OFF%
			CALL	STOR_NEXT
			ADD	SP,4
			MOV	%OFF%,AX
			JMP	%LOOP%
		%DONE%:
		}
	%END%:
	}
  }
 }
}

{(PROC(ADD_STOR))
 {(ARG(S,BUF,LEN))
  {(LOCAL(I))
	MOV	BX,[STORLEN]
	{(IF)
		CMP	BX,STORSIZE
		JNB	%ENDIF%
		MOV	AL,%S%
		MOV	[OFFSET STOR+BX],AL
		INC	BX
	%ENDIF%:
	}
	{(IF)
		CMP	BX,STORSIZE
		JNB	%ENDIF%
		MOV	AL,%LEN%
		MOV	[OFFSET STOR+BX],AL
		INC	BX
	%ENDIF%:
	}
	MOV	WORD PTR %I%,0
	{(WHILE)
	%LOOP%:
		MOV	AX,%I%
		CMP	AX,%LEN%
		JNB	%DONE%
		CMP	BX,STORSIZE
		JNB	%DONE%
		MOV	SI,%BUF%
		ADD	SI,%I%
		MOV	AL,[SI]
		MOV	[OFFSET STOR+BX],AL
		INC	BX
		INC	WORD PTR %I%
		JMP	%LOOP%
	%DONE%:
	}
	MOV	[STORLEN],BX
	{(IF)
		MOV	AX,%I%
		CMP	AX,%LEN%
		JNB	%ENDIF%
		MOV	AX,OFFSET MSG_OUT_OF_MEMORY
		PUSH	AX
		CALL	ERR_EXIT
		POP	AX
	%ENDIF%:
	}
  }
 }
}

{(PROC(IS_KEY_IN_WORDS))
 {(ARG(BUF,KEY))
  {(LOCAL(WORD,LEN,I))
	{(WHILE)
	%LOOP%:
		MOV	AX,%BUF%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN%,AX
		TEST	AX,AX
		JE	%DONE%
		MOV	WORD PTR %I%,0
		{((LOOP,DIFF))
		%LOOP%:
			MOV	BX,%KEY%
			ADD	BX,%I%
			{(IF)
				CMP	BYTE PTR [BX],0
				JNE	%ENDIF%
				MOV	AX,1
				JMP	%DONE%
			%ENDIF%:
			}
			MOV	AX,%I%
			CMP	AX,%LEN%
			JAE	%DIFF%
			MOV	BX,%WORD%
			ADD	BX,%I%
			XOR	AX,AX
			MOV	AL,[BX]
			PUSH	AX
			CALL	TO_UPPER
			ADD	SP,2
			PUSH	AX
			MOV	BX,%KEY%
			ADD	BX,%I%
			XOR	AX,AX
			MOV	AL,[BX]
			PUSH	AX
			CALL	TO_UPPER
			ADD	SP,2
			POP	BX
			CMP	AX,BX
			JNE	%DIFF%
			INC	WORD PTR %I%
			JMP	%LOOP%
		%DIFF%:
		}
		MOV	AX,%WORD%
		ADD	AX,%LEN%
		MOV	%BUF%,AX
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(FIND_SYMS))
 {(ARG(BUF))
  {(LOCAL(WORD,LEN))
	{(WHILE)
	%LOOP%:
		MOV	AX,%BUF%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN%,AX
		TEST	AX,AX
		JE	%DONE%
		PUSH	%LEN%
		PUSH	%WORD%
		CALL	FIND_SYM
		ADD	SP,4
		{(IF)
			TEST	AX,AX
			JE	%ENDIF%
			MOV	AX,1
			JMP	SHORT %DONE%
		%ENDIF%:
		}
		MOV	AX,%WORD%
		ADD	AX,%LEN%
		MOV	%BUF%,AX
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(NEED_WORDS))
 {(ARG(BUF))
  {(LOCAL(WORD,LEN))
	{(WHILE)
	%LOOP%:
		MOV	AX,%BUF%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN%,AX
		TEST	AX,AX
		JE	%DONE%
		PUSH	%LEN%
		PUSH	%WORD%
		CALL	NEED_WORD
		ADD	SP,4
		MOV	AX,%WORD%
		ADD	AX,%LEN%
		MOV	%BUF%,AX
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(ADD_REL_WORDS))
 {(ARG(BUF))
  {(LOCAL(WORD,LEN))
	{(WHILE)
	%LOOP%:
		MOV	AX,%BUF%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN%,AX
		TEST	AX,AX
		JE	%DONE%
		PUSH	%LEN%
		PUSH	%WORD%
		MOV	AX,STOR_REL
		PUSH	AX
		CALL	ADD_STOR
		ADD	SP,6
		MOV	AX,%WORD%
		ADD	AX,%LEN%
		MOV	%BUF%,AX
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(PASS1))
 {(ARG(BUF,WORD,LEN,WORD2,LEN2))
  {((RET))
	{(IF)
		CMP	WORD PTR IN_STRUC,0
		{((SKIP))
			JNE	%SKIP%
			JMP	%ENDIF%
		%SKIP%:
		}
		{(IF)
			MOV	AX,4
			PUSH	AX
			MOV	AX,OFFSET STR_ENDS
			PUSH	AX
			PUSH	%LEN2%
			PUSH	%WORD2%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ELSE%
			MOV	WORD PTR [IN_STRUC],0
			PUSH	%BUF%
			CALL	ADD_REL_WORDS
			POP	AX
			XOR	AX,AX
			PUSH	AX
			PUSH	AX
			MOV	AX,STOR_END
			PUSH	AX
			CALL	ADD_STOR
			ADD	SP,6
			JMP	%ENDIF%
		%ELSE%:
			{(IF)
				MOV	AX,2
				PUSH	AX
				MOV	AX,OFFSET STR_DB
				PUSH	AX
				PUSH	%LEN2%
				PUSH	%WORD2%
				CALL	CMP_WORD
				ADD	SP,8
				TEST	AX,AX
				JNE	%THEN%
				MOV	AX,2
				PUSH	AX
				MOV	AX,OFFSET STR_DW
				PUSH	AX
				PUSH	%LEN2%
				PUSH	%WORD2%
				CALL	CMP_WORD
				ADD	SP,8
				TEST	AX,AX
				JNE	%THEN%
				MOV	AX,2
				PUSH	AX
				MOV	AX,OFFSET STR_DD
				PUSH	AX
				PUSH	%LEN2%
				PUSH	%WORD2%
				CALL	CMP_WORD
				ADD	SP,8
				TEST	AX,AX
				JE	%ENDIF%
			%THEN%:
				{(IF)
					PUSH	%LEN%
					PUSH	%WORD%
					CALL	FIND_SYM
					ADD	SP,4
					TEST	AX,AX
					JE	%ENDIF%
					MOV	AX,OFFSET MSG_STRUC2
					PUSH	AX
					CALL	ERR_EXIT
					POP	AX
				%ENDIF%:
				}
				PUSH	%LEN%
				PUSH	%WORD%
				MOV	AX,STOR_SYM
				PUSH	AX
				CALL	ADD_STOR
				ADD	SP,6
			%ENDIF%:
			}
			PUSH	%BUF%
			CALL	ADD_REL_WORDS
			POP	AX
		%ENDIF%:
		}
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,5
		PUSH	AX
		MOV	AX,OFFSET STR_STRUC
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
		MOV	WORD PTR [IN_STRUC],1
		{(IF)
			PUSH	%LEN%
			PUSH	%WORD%
			CALL	FIND_SYM
			ADD	SP,4
			TEST	AX,AX
			JE	%ENDIF%
			MOV	AX,OFFSET MSG_STRUC
			PUSH	AX
			CALL	ERR_EXIT
			POP	AX
		%ENDIF%:
		}
		PUSH	%LEN%
		PUSH	%WORD%
		MOV	AX,STOR_SYM OR STOR_BEGIN
		PUSH	AX
		CALL	ADD_STOR
		ADD	SP,6
		PUSH	%BUF%
		CALL	ADD_REL_WORDS
		POP	AX
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,3
		PUSH	AX
		MOV	AX,OFFSET STR_EQU
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JNE	%THEN%
		MOV	AX,1
		PUSH	AX
		MOV	AX,OFFSET STR_EQUAL
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
	%THEN%:
		{(IF)
			CMP	WORD PTR %LEN%,8
			JNB	%ELSE%
			PUSH	%BUF%
			CALL	FIND_SYMS
			ADD	SP,2
			TEST	AX,AX
			JNE	%ELSE%
			JMP	%ENDIF%
		%ELSE%:
			{(IF)
				PUSH	%LEN%
				PUSH	%WORD%
				CALL	FIND_SYM
				ADD	SP,4
				TEST	AX,AX
				JE	%ELSE%
				PUSH	%LEN%
				PUSH	%WORD%
				CALL	NEED_WORD
				ADD	SP,4
				JMP	%ENDIF%
			%ELSE%:
				PUSH	%LEN%
				PUSH	%WORD%
				MOV	AX,STOR_SYM OR STOR_BEGIN
				PUSH	AX
				CALL	ADD_STOR
				ADD	SP,6
				PUSH	%BUF%
				CALL	ADD_REL_WORDS
				POP	AX
				XOR	AX,AX
				PUSH	AX
				PUSH	AX
				MOV	AX,STOR_END
				PUSH	AX
				CALL	ADD_STOR
				ADD	SP,6
			%ENDIF%:
			}
		%ENDIF%:
		}
	%ENDIF%:
	}
  %RET%:
  }
 }
}

{(PROC(PASS2))
 {(ARG(BUF,WORD,LEN,WORD2,LEN2))
  {((RET))
	MOV	AX,5
	PUSH	AX
	MOV	AX,OFFSET STR_BREAK
	PUSH	AX
	PUSH	%LEN%
	PUSH	%WORD%
	CALL	CMP_WORD
	ADD	SP,8
	TEST	AX,AX
	{((SKIP))
		JE	%SKIP%
		JMP	%RET%
	%SKIP%:
	}
	{(IF)
		CMP	WORD PTR [IN_STRUC],0
		JE	%ENDIF%
		{(IF)
			MOV	AX,4
			PUSH	AX
			MOV	AX,OFFSET STR_ENDS
			PUSH	AX
			PUSH	%LEN2%
			PUSH	%WORD2%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ENDIF%
			MOV	WORD PTR [IN_STRUC],0
		%ENDIF%:
		}
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,5
		PUSH	AX
		MOV	AX,OFFSET STR_STRUC
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
		MOV	WORD PTR [IN_STRUC],1
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,3
		PUSH	AX
		MOV	AX,OFFSET STR_EQU
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JNE	%THEN%
		MOV	AX,1
		PUSH	AX
		MOV	AX,OFFSET STR_EQUAL
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
	%THEN%:
		JMP	%RET%
	%ENDIF%:
	}
	PUSH	%BUF%
	CALL	NEED_WORDS
	POP	AX
  %RET%:
  }
 }
}

{(PROC(PASS3))
 {(ARG(BUF,WORD,LEN,WORD2,LEN2))
  {(LOCAL(S,UNUSED))
   {((RET))
	MOV	WORD PTR %UNUSED%,0
	{(IF)
		CMP	WORD PTR [IN_STRUC],0
		JE	%ENDIF%
		{(IF)
			CMP	WORD PTR [IN_STRUC],2
			JNE	%ENDIF%
			MOV	WORD PTR %UNUSED%,1
		%ENDIF%:
		}
		{(IF)
			MOV	AX,4
			PUSH	AX
			MOV	AX,OFFSET STR_ENDS
			PUSH	AX
			PUSH	%LEN2%
			PUSH	%WORD2%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ENDIF%
			MOV	WORD PTR [IN_STRUC],0
		%ENDIF%:
		}
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,5
		PUSH	AX
		MOV	AX,OFFSET STR_STRUC
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
		MOV	WORD PTR [IN_STRUC],1
		PUSH	%LEN%
		PUSH	%WORD%
		CALL	FIND_SYM
		ADD	SP,4
		MOV	%S%,AX
		{(IF)
			TEST	AX,AX
			JE	%ENDIF%
			TEST	AX,STOR_NEED
			JNE	%ENDIF%
			MOV	WORD PTR [IN_STRUC],2
			MOV	WORD PTR %UNUSED%,1
		%ENDIF%:
		}
		JMP	%RET%
	%ENDIF%:
	}
	{(IF)
		MOV	AX,3
		PUSH	AX
		MOV	AX,OFFSET STR_EQU
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JNE	%THEN%
		MOV	AX,1
		PUSH	AX
		MOV	AX,OFFSET STR_EQUAL
		PUSH	AX
		PUSH	%LEN2%
		PUSH	%WORD2%
		CALL	CMP_WORD
		ADD	SP,8
		TEST	AX,AX
		JE	%ENDIF%
	%THEN%:
		PUSH	%LEN%
		PUSH	%WORD%
		CALL	FIND_SYM
		ADD	SP,4
		MOV	%S%,AX
		{(IF)
			TEST	AX,AX
			JE	%ENDIF%
			TEST	AX,STOR_NEED
			JNE	%ENDIF%
			MOV	WORD PTR %UNUSED%,1
		%ENDIF%:
		}
	%ENDIF%:
	}
   %RET%:
	{(IF)
		CMP	WORD PTR %UNUSED%,0
		JE	%ENDIF%
		MOV	AX,OFFSET STR_UNUSED
		PUSH	AX
		CALL	PRINT
		POP	AX
	%ENDIF%:
	}
	PUSH	%BUF%
	CALL	PRINT
	POP	AX
	MOV	AX,OFFSET STR_CRLF
	PUSH	AX
	CALL	PRINT
	POP	AX
   }
  }
 }
}

{(PROC(PASS))
 {(ARG(BUF,BUFLEN,FP,HANDLER))
  {(LOCAL(FP2,WORD,LEN,WORD2,LEN2,FILENAME))
	{(WHILE)
	%LOOP%:
		PUSH	%BUFLEN%
		PUSH	%BUF%
		PUSH	%FP%
		CALL	GET_LINE
		ADD	SP,6
		TEST	AX,AX
		{((SKIP))
			JNE	%SKIP%
			JMP	%DONE%
		%SKIP%:
		}
		MOV	AX,%BUF%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN%,AX
		{(IF)
			MOV	AX,7
			PUSH	AX
			MOV	AX,OFFSET STR_INCLUDE
			PUSH	AX
			PUSH	%LEN%
			PUSH	%WORD%
			CALL	CMP_WORD
			ADD	SP,8
			TEST	AX,AX
			JE	%ENDIF%
			MOV	AX,%WORD%
			ADD	AX,%LEN%
			PUSH	AX
			CALL	GET_WORD_START
			ADD	SP,2
			PUSH	AX
			CALL	GET_STRING
			ADD	SP,2
			MOV	%FILENAME%,AX
			PUSH	AX
			CALL	OPEN_FOR_READ
			ADD	SP,2
			MOV	%FP2%,AX
			{(IF)
				TEST	AX,AX
				JNE	%ENDIF%
				MOV	AX,OFFSET MSG_OPEN_ERROR
				PUSH	AX
				CALL	ERR_EXIT
				POP	AX
			%ENDIF%:
			}
			PUSH	%HANDLER%
			PUSH	%FP2%
			PUSH	%BUFLEN%
			PUSH	%BUF%
			CALL	PASS
			ADD	SP,8
			PUSH	%FP2%
			CALL	CLOSE
			POP	AX
			JMP	%LOOP%
		%ENDIF%:
		}
		MOV	AX,%WORD%
		ADD	AX,%LEN%
		PUSH	AX
		CALL	GET_WORD_START
		ADD	SP,2
		MOV	%WORD2%,AX
		PUSH	AX
		CALL	GET_WORD_LEN
		ADD	SP,2
		MOV	%LEN2%,AX
		PUSH	AX
		PUSH	%WORD2%
		PUSH	%LEN%
		PUSH	%WORD%
		PUSH	%BUF%
		CALL	%HANDLER%
		ADD	SP,10
		JMP	%LOOP%
	%DONE%:
	}
  }
 }
}

{(PROC(MAIN))
 {(ARG(FILENAME))
  {(LOCAL(FP))
	PUSH	%FILENAME%
	CALL	OPEN_FOR_READ
	ADD	SP,2
	MOV	%FP%,AX
	{(IF)
		TEST	AX,AX
		JNE	%ENDIF%
		MOV	AX,OFFSET MSG_OPEN_ERROR
		PUSH	AX
		CALL	ERR_EXIT
		POP	AX
	%ENDIF%:
	}
	MOV	AX,OFFSET PASS1
	PUSH	AX
	PUSH	%FP%
	MOV	AX,SIZEOF_BUF
	PUSH	AX
	MOV	AX,OFFSET BUF
	PUSH	AX
	CALL	PASS
	ADD	SP,8
	PUSH	%FP%
	CALL	REWIND
	POP	AX
	MOV	AX,OFFSET PASS2
	PUSH	AX
	PUSH	%FP%
	MOV	AX,SIZEOF_BUF
	PUSH	AX
	MOV	AX,OFFSET BUF
	PUSH	AX
	CALL	PASS
	ADD	SP,8
	PUSH	%FP%
	CALL	REWIND
	POP	AX
	MOV	AX,OFFSET PASS3
	PUSH	AX
	PUSH	%FP%
	MOV	AX,SIZEOF_BUF
	PUSH	AX
	MOV	AX,OFFSET BUF
	PUSH	AX
	CALL	PASS
	ADD	SP,8
	PUSH	%FP%
	CALL	CLOSE
	POP	AX
	MOV	AX,OFFSET STR_END1
	PUSH	AX
	CALL	PRINT
	POP	AX
	PUSH	[STORLEN]
	CALL	PRINT_VALUE
	POP	AX
	MOV	AX,OFFSET STR_END2
	PUSH	AX
	CALL	PRINT
	POP	AX
	XOR	AX,AX
  }
 }
}

;TYPE
;CHAR_SEPARATOR	EQU	0
;CHAR_COMMENT	EQU	2
;CHAR_STRING	EQU	3
;CHAR_SYMBOL	EQU	4
;CHAR_OPERATOR	EQU	5
; 2 COMMENT	3BH
; 3 STRING	22H OR 27H
; 0 SEPARATOR	00H-20H
; 5 OPERATOR	21H OR 23H OR 26H-2FH OR 3AH-3EH OR 5BH-5DH OR 7BH-7DH
; 4 SYMBOL
;TYPE MATRIX
; NEXT NOW 0 2 3 4 5
; 0        0 2 3 0 0
; 2        2 2 3 2 2
; 3        3 2 0 3 3
; 4        4 2 3 4 4
; 5        5 2 3 5 5
TYPETBL	LABEL	BYTE
	;;   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	DB 00H,00H,02H,03H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	DB 00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	DB 02H,50H,32H,53H,42H,42H,50H,30H,50H,50H,50H,50H,50H,50H,50H,50H
	DB 43H,40H,42H,40H,43H,43H,40H,40H,40H,40H,50H,20H,50H,50H,50H,40H
	DB 44H,40H,42H,43H,44H,44H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 45H,40H,42H,43H,45H,45H,40H,40H,40H,40H,40H,50H,40H,50H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,50H,40H,50H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
	DB 40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H,40H
MSG_TOOLONG		DB	'TOO LONG',0
MSG_INTERNAL_ERROR	DB	'INTERNAL ERROR',0
MSG_OPEN_ERROR		DB	'OPEN ERROR',0
MSG_WRITE_ERROR		DB	'WRITE ERROR',0
MSG_OUT_OF_MEMORY	DB	'OUT OF MEMORY',0
MSG_STRUC		DB	'STRUC NAME ALREADY EXISTS',0
MSG_STRUC2		DB	'STRUC MEMBER NAME ALREADY EXISTS',0
STR_CRLF		DB	13,10,0
STR_ENDS		DB	'ENDS'
STR_DB			DB	'DB'
STR_DW			DB	'DW'
STR_DD			DB	'DD'
STR_STRUC		DB	'STRUC'
STR_EQU			DB	'EQU'
STR_EQUAL		DB	'='
STR_BREAK		DB	'BREAK'
STR_INCLUDE		DB	'INCLUDE'
STR_UNUSED		DB	';UNUSED;',0
STR_END1		DB	'; (',0
STR_END2		DB	')',13,10,0
STORLEN			DW	0
IN_STRUC		DW	0

STACK	EQU	$+4096
BUF	EQU	$+4096
STOR	EQU	BUF+SIZEOF_BUF

A	ENDS
	END	START
